<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Melody Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        h1, h2 {
            color: #333;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #status {
            margin-top: 10px;
            font-style: italic;
        }
        #visualizer {
            height: 80px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
        }
        .note-display {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .note-item {
            padding: 5px 10px;
            background-color: #e0e0e0;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simple Melody Generator</h1>
        
        <div class="panel">
            <h2>Settings</h2>
            <div class="controls">
                <div>
                    <label for="key">Key:</label>
                    <select id="key">
                        <option value="C">C</option>
                        <option value="C#">C#</option>
                        <option value="D">D</option>
                        <option value="D#">D#</option>
                        <option value="E">E</option>
                        <option value="F">F</option>
                        <option value="F#">F#</option>
                        <option value="G">G</option>
                        <option value="G#">G#</option>
                        <option value="A">A</option>
                        <option value="A#">A#</option>
                        <option value="B">B</option>
                    </select>
                </div>
                <div>
                    <label for="scale">Scale:</label>
                    <select id="scale">
                        <option value="major">Major (1,2,3,4,5,6,7)</option>
                        <option value="minor">Minor (1,2,2#,4,5,5#,7)</option>
                        <option value="pentatonic">Pentatonic (1,2,3,5,6)</option>
                        <option value="blues">Blues (1,3,4,5,7)</option>
                    </select>
                </div>
                <div>
                    <label for="lowNote">Low Note:</label>
                    <select id="lowNote"></select>
                </div>
                <div>
                    <label for="highNote">High Note:</label>
                    <select id="highNote"></select>
                </div>
                <div>
                    <label for="numNotes">Number of Notes:</label>
                    <input type="number" id="numNotes" min="1" max="16" value="8">
                </div>
                <div>
                  <label for="minInterval">Min Interval:</label>
                  <input type="number" id="minInterval" min="1" max="24" value="0">
              </div>
                <div>
                    <label for="maxInterval">Max Interval:</label>
                    <input type="number" id="maxInterval" min="1" max="24" value="12">
                </div>
                <div>
                    <label for="beats">Total Beats:</label>
                    <input type="number" id="beats" min="1" max="16" value="4">
                </div>
                <div>
                    <label for="bpm">BPM:</label>
                    <input type="number" id="bpm" min="40" max="240" value="120">
                </div>
                <div>
                    <label for="shortestDuration">Shortest Duration:</label>
                    <select id="shortestDuration">
                        <option value="32n">32nd Note</option>
                        <option value="16n">16th Note</option>
                        <option value="8n" selected>8th Note</option>
                        <option value="4n">Quarter Note</option>
                    </select>
                </div>
                <div>
                    <label for="longestDuration">Longest Duration:</label>
                    <select id="longestDuration">
                        <option value="8n">8th Note</option>
                        <option value="4n">Quarter Note</option>
                        <option value="2n" selected>Half Note</option>
                        <option value="1n">Whole Note</option>
                    </select>
                </div>
                <div>
                    <label for="allowRests">Allow Rests:</label>
                    <input type="checkbox" id="allowRests" checked>
                </div>
                <div>
                    <label for="restProb">Rest Probability:</label>
                    <input type="range" id="restProb" min="0" max="50" value="20">
                    <span id="restProbValue">20%</span>
                </div>
                <div>
                    <label for="loop">Loop Playback:</label>
                    <input type="checkbox" id="loop" checked>
                </div>
                <div class="full-width">
                    <button id="generateBtn">Generate & Play</button>
                    <button id="stopBtn" disabled>Stop</button>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Generated Melody</h2>
            <div id="status">Ready to generate melody</div>
            <div id="visualizer">
                <div>Press "Generate & Play" to create a melody</div>
            </div>
            <div>
                <h3>Notes:</h3>
                <div id="noteDisplay" class="note-display"></div>
            </div>
            <div>
                <h3>Rhythm:</h3>
                <div id="rhythmDisplay" class="note-display"></div>
            </div>
        </div>
    </div>

    <script>
        // Define allNotes array
        const allNotes = [
            "A0", "A#0", "B0",
            "C1", "C#1", "D1", "D#1", "E1", "F1", "F#1", "G1", "G#1", "A1", "A#1", "B1",
            "C2", "C#2", "D2", "D#2", "E2", "F2", "F#2", "G2", "G#2", "A2", "A#2", "B2",
            "C3", "C#3", "D3", "D#3", "E3", "F3", "F#3", "G3", "G#3", "A3", "A#3", "B3",
            "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4",
            "C5", "C#5", "D5", "D#5", "E5", "F5", "F#5", "G5", "G#5", "A5", "A#5", "B5",
            "C6", "C#6", "D6", "D#6", "E6", "F6", "F#6", "G6", "G#6", "A6", "A#6", "B6",
            "C7", "C#7", "D7", "D#7", "E7", "F7", "F#7", "G7", "G#7", "A7", "A#7", "B7",
            "C8"
        ];

        // Helper function to get scale degrees from scale name
        function getScaleDegrees(scaleName) {
            switch(scaleName) {
                case "major": return ["1", "2", "3", "4", "5", "6", "7"];
                case "minor": return ["1", "2", "2#", "4", "5", "5#", "7"];
                case "pentatonic": return ["1", "2", "3", "5", "6"];
                case "blues": return ["1", "3", "4", "5", "7"];
                default: return ["1", "2", "3", "4", "5", "6", "7"];
            }
        }

        // Rhythm generator function
        const rhythmGenerator = ({
            totalBeats = 4,
            shortestDuration = "8n",
            longestDuration = "2n",
            n = 4,
            allowRests = true,
            restProbability = 0.2
        } = {}) => {
            const durationValues = {
                "32n": 1 / 8,
                "16n": 1 / 4,
                "8n": 1 / 2,
                "4n": 1,
                "2n": 2,
                "1n": 4
            };

            const minDuration = durationValues[shortestDuration];
            const maxDuration = durationValues[longestDuration];

            const result = [];

            let remainingBeats = totalBeats;
            let remainingNotes = n;

            const getRandomDuration = (min, max) => {
                const availableDurations = Object.entries(durationValues)
                    .filter(([_, value]) => value >= min && value <= max)
                    .map(([name, value]) => ({ name, value }));

                if (availableDurations.length === 0) {
                    throw new Error(`No available durations between ${min} and ${max}`);
                }

                const randomIndex = Math.floor(Math.random() * availableDurations.length);
                return availableDurations[randomIndex];
            };

            const getDurationNotation = (value) => {
                for (const [notation, val] of Object.entries(durationValues)) {
                    if (val === value) return notation;
                }
                return null;
            };

            while (remainingNotes > 0) {
                const maxPossibleDuration = Math.min(
                    maxDuration,
                    remainingBeats - ((remainingNotes - 1) * minDuration)
                );

                if (maxPossibleDuration < minDuration) {
                    console.error("Can't fit the remaining notes with the given constraints");
                    break;
                }

                const canAddRest = allowRests && (remainingBeats - ((remainingNotes) * minDuration)) > 0;

                const isRest = canAddRest && Math.random() < restProbability;

                const randomDuration = getRandomDuration(minDuration, maxPossibleDuration);

                result.push({
                    type: isRest ? "rest" : "note",
                    duration: randomDuration.name,
                    value: randomDuration.value
                });

                if (!isRest) {
                    remainingNotes--;
                }

                remainingBeats -= randomDuration.value;
            }

            while (remainingBeats >= minDuration && allowRests) {
                const maxPossibleRestDuration = Math.min(maxDuration, remainingBeats);

                const randomDuration = getRandomDuration(minDuration, maxPossibleRestDuration);

                result.push({
                    type: "rest",
                    duration: randomDuration.name,
                    value: randomDuration.value
                });

                remainingBeats -= randomDuration.value;
            }

            if (remainingBeats > 0 && remainingBeats < minDuration) {
                const lastElement = result[result.length - 1];
                const newDurationValue = lastElement.value + remainingBeats;

                const exactMatchDuration = getDurationNotation(newDurationValue);
                if (exactMatchDuration) {
                    lastElement.duration = exactMatchDuration;
                } else {
                    lastElement.duration = `~${lastElement.duration}`;
                }
                lastElement.value = newDurationValue;
                remainingBeats = 0;
            }

            return result;
        };

        // Helper function to convert note degrees to actual notes
        const getNoteFromDegree = (degree, keyId) => {
            const chromaticNotes = [
                "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"
            ];

            const keyIndex = chromaticNotes.indexOf(keyId);
            if (keyIndex === -1) {
                return "?";
            }

            let semitoneOffset;
            switch (degree) {
                case "1": semitoneOffset = 0; break;
                case "1#": semitoneOffset = 1; break;
                case "2": semitoneOffset = 2; break;
                case "2#": semitoneOffset = 3; break;
                case "3": semitoneOffset = 4; break;
                case "4": semitoneOffset = 5; break;
                case "4#": semitoneOffset = 6; break;
                case "5": semitoneOffset = 7; break;
                case "5#": semitoneOffset = 8; break;
                case "6": semitoneOffset = 9; break;
                case "6#": semitoneOffset = 10; break;
                case "7": semitoneOffset = 11; break;
                default: return "?";
            }

            const noteIndex = (keyIndex + semitoneOffset) % 12;
            return chromaticNotes[noteIndex];
        };

        // Available notes function
        const availableNotes = ({
            allNotes,
            range,
            notes,
            keyId
        }) => {
            if (!range || range.length !== 2) {
                return [];
            }

            const startIndex = allNotes.indexOf(range[0]);
            const endIndex = allNotes.indexOf(range[1]);

            if (startIndex === -1 || endIndex === -1 || startIndex > endIndex) {
                return [];
            }

            const notesInRange = allNotes.slice(startIndex, endIndex + 1);

            if (!notes || notes.length === 0) {
                return notesInRange;
            }

            const chromaticNotes = [
                "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"
            ];

            // Map scale degrees to actual notes
            const scaleNotes = notes.map(degree => getNoteFromDegree(degree, keyId));

            const result = notesInRange.filter(fullNote => {
                const noteName = fullNote.replace(/\d+$/, '');
                return scaleNotes.includes(noteName);
            });

            return result;
        };

        // Calculate interval between notes
        const calculateInterval = (note1, note2) => {
            const index1 = allNotes.indexOf(note1);
            const index2 = allNotes.indexOf(note2);

            if (index1 === -1 || index2 === -1) {
                throw new Error(`Invalid note: ${index1 === -1 ? note1 : note2}`);
            }

            return Math.abs(index1 - index2);
        };

        // Note sequence generator
        const generateNoteSequence = ({
            keyId,
            notes,
            range,
            numberOfNotes,
            maxInterval,
            minInterval
        }) => {
            try {
                const available = availableNotes({
                    allNotes,
                    range,
                    notes,
                    keyId: keyId || ''
                });

                if (available.length === 0) {
                    return [];
                }

                const notesWithNulls = allNotes.map(note =>
                    available.includes(note) ? note : null
                );

                const newSequence = [];

                const validInitialNotes = notesWithNulls.filter(note => note !== null);
                const firstNoteIndex = Math.floor(Math.random() * validInitialNotes.length);
                const firstNote = validInitialNotes[firstNoteIndex];
                newSequence.push(firstNote);

                for (let i = 1; i < numberOfNotes; i++) {
                    const previousNote = newSequence[i - 1];
                    const validNotes = [];

                    for (let j = 0; j < notesWithNulls.length; j++) {
                        const note = notesWithNulls[j];

                        if (note === null) continue;

                        const interval = calculateInterval(note, previousNote);

                        const meetsMaxConstraint = maxInterval === undefined || interval <= maxInterval;
                        const meetsMinConstraint = minInterval === undefined || interval >= minInterval;

                        if (meetsMaxConstraint && meetsMinConstraint) {
                            validNotes.push(note);
                        }
                    }

                    if (validNotes.length === 0) {
                        console.error(`No valid notes meet interval constraints from ${previousNote}`);
                        break;
                    }

                    const nextNoteIndex = Math.floor(Math.random() * validNotes.length);
                    const nextNote = validNotes[nextNoteIndex];

                    newSequence.push(nextNote);
                }

                return newSequence;
            } catch (error) {
                console.error(error);
                return [];
            }
        };

        // Adapted playSequence function 
        const playSequence = async ({ 
            keyId = "", 
            notes = [], 
            range = ["C3", "C5"], 
            numberOfNotes = 8, 
            maxInterval = 12, 
            minInterval = 1,
            totalBeats = 4, 
            shortestDuration = "8n", 
            longestDuration = "2n", 
            allowRests = true, 
            restProbability = 0.2,
            loop = false,
            bpm = 120
        } = {}) => {
            // Ensure audio context is running
            if (Tone.context.state !== "running") {
                await Tone.start();
            }
            
            // Set the BPM
            Tone.Transport.bpm.value = bpm;
            
            // Generate the note sequence
            const generatedNotes = generateNoteSequence({
                keyId,
                notes,
                range,
                numberOfNotes,
                maxInterval,
                minInterval
            });
            
            if (!generatedNotes || generatedNotes.length === 0) {
                console.error("Failed to generate notes");
                return { play: () => {}, stop: () => {}, isPlaying: false };
            }
            
            // Generate the rhythm pattern
            const rhythmPattern = rhythmGenerator({
                totalBeats,
                shortestDuration,
                longestDuration,
                n: generatedNotes.length,
                allowRests,
                restProbability
            });
            
            // Create the full sequence by combining notes and rhythm
            const fullSequence = [];
            let noteIndex = 0;
            
            for (const rhythmItem of rhythmPattern) {
                if (rhythmItem.type === "note" && noteIndex < generatedNotes.length) {
                    fullSequence.push({
                        type: "note",
                        note: generatedNotes[noteIndex],
                        duration: rhythmItem.duration,
                        value: rhythmItem.value
                    });
                    noteIndex++;
                } else if (rhythmItem.type === "rest") {
                    fullSequence.push({
                        type: "rest",
                        duration: rhythmItem.duration,
                        value: rhythmItem.value
                    });
                }
            }
            
            // Create the synth
            const piano = new Tone.PolySynth(Tone.Synth).toDestination();
            const metronome = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();
            
            // State variables
            let isPlaying = false;
            let currentSequence = null;
            let loopCount = 0;
            
            // The play function
            const play = () => {
                if (isPlaying) return;
                
                // Clean up any existing sequence
                if (currentSequence) {
                    currentSequence.dispose();
                }
                
                loopCount = 0;
                isPlaying = true;
                
                let index = 0;
                currentSequence = new Tone.Sequence(
                    (time, value) => {
                        // Play metronome at the start of each loop
                        if (index === 0 && loop && loopCount > 0) {
                            metronome.triggerAttackRelease("C2", "16n", time);
                        }
                        
                        // Get the current item
                        const currentItem = fullSequence[index];
                        
                        if (currentItem && currentItem.type === "note") {
                            piano.triggerAttackRelease(currentItem.note, currentItem.duration, time);
                            
                            // Update visualizer
                            document.getElementById('visualizer').innerHTML = `Playing: ${currentItem.note} (${currentItem.duration})`;
                        } else if (currentItem && currentItem.type === "rest") {
                            document.getElementById('visualizer').innerHTML = `Rest: ${currentItem.duration}`;
                        }
                        
                        index++;
                        
                        if (index >= fullSequence.length) {
                            loopCount++;
                            
                            if (!loop) {
                                Tone.Transport.scheduleOnce(() => {
                                    stop();
                                }, "+0.1");
                                return;
                            }
                            
                            index = 0; // Reset for looping
                        }
                    },
                    fullSequence,
                    "4n"
                );
                
                currentSequence.start(0);
                
                if (Tone.Transport.state !== "started") {
                    Tone.Transport.start();
                }
            };
            
            // The stop function
            const stop = () => {
                if (currentSequence) {
                    currentSequence.stop();
                    currentSequence.dispose();
                    currentSequence = null;
                }
                Tone.Transport.stop();
                isPlaying = false;
                document.getElementById('visualizer').innerHTML = 'Stopped';
            };
            
            // Return the melody object
            return {
                notes: generatedNotes,
                durations: rhythmPattern.map(item => item.duration),
                fullSequence,
                play,
                stop,
                get isPlaying() { return isPlaying; }
            };
        };

        // Initialize UI
        let currentMelody = null;

        // Populate note selectors
        const lowNoteSelect = document.getElementById('lowNote');
        const highNoteSelect = document.getElementById('highNote');

        // Add piano range notes (C2 to C6)
        const pianoRange = allNotes.slice(allNotes.indexOf('C2'), allNotes.indexOf('C6') + 1);
        pianoRange.forEach(note => {
            const lowOption = document.createElement('option');
            lowOption.value = note;
            lowOption.textContent = note;
            lowNoteSelect.appendChild(lowOption);
            
            const highOption = document.createElement('option');
            highOption.value = note;
            highOption.textContent = note;
            highNoteSelect.appendChild(highOption);
        });

        // Set default values
        lowNoteSelect.value = 'C3';
        highNoteSelect.value = 'C5';

        // Update rest probability value display
        document.getElementById('restProb').addEventListener('input', function() {
            document.getElementById('restProbValue').textContent = this.value + '%';
        });

        // Generate and play button
        document.getElementById('generateBtn').addEventListener('click', async function() {
            // Get all parameters from UI
            const keyId = document.getElementById('key').value;
            const scale = document.getElementById('scale').value;
            const notes = getScaleDegrees(scale);
            const range = [
                document.getElementById('lowNote').value,
                document.getElementById('highNote').value
            ];
            const numberOfNotes = parseInt(document.getElementById('numNotes').value);
            const maxInterval = parseInt(document.getElementById('maxInterval').value);
            const minInterval = parseInt(document.getElementById('minInterval').value);
            const totalBeats = parseInt(document.getElementById('beats').value);
            const shortestDuration = document.getElementById('shortestDuration').value;
            const longestDuration = document.getElementById('longestDuration').value;
            const allowRests = document.getElementById('allowRests').checked;
            const restProbability = parseInt(document.getElementById('restProb').value) / 100;
            const loop = document.getElementById('loop').checked;
            const bpm = parseInt(document.getElementById('bpm').value);

            // Update status
            document.getElementById('status').textContent = 'Generating melody...';

            try {
                // Stop any existing melody
                if (currentMelody && currentMelody.isPlaying) {
                    currentMelody.stop();
                }

                // Generate new melody
                currentMelody = await playSequence({
                    keyId,
                    notes,
                    range,
                    numberOfNotes,
                    maxInterval,
                    minInterval,
                    totalBeats,
                    shortestDuration,
                    longestDuration,
                    allowRests,
                    restProbability,
                    loop,
                    bpm
                });

                // Update UI
                document.getElementById('status').textContent = 'Melody generated!';
                document.getElementById('generateBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

                // Display notes
                const noteDisplay = document.getElementById('noteDisplay');
                noteDisplay.innerHTML = '';
                currentMelody.notes.forEach(note => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'note-item';
                    noteItem.textContent = note;
                    noteDisplay.appendChild(noteItem);
                });

                // Display rhythm
                const rhythmDisplay = document.getElementById('rhythmDisplay');
                rhythmDisplay.innerHTML = '';
                currentMelody.fullSequence.forEach(item => {
                    const rhythmItem = document.createElement('div');
                    rhythmItem.className = 'note-item';
                    rhythmItem.textContent = item.type === 'note' ? item.duration : 'rest ' + item.duration;
                    rhythmDisplay.appendChild(rhythmItem);
                });

                // Play the melody
                currentMelody.play();
            } catch (error) {
                console.error('Error generating melody:', error);
                document.getElementById('status').textContent = 'Error: ' + error.message;
            }
        });

        // Stop button
        document.getElementById('stopBtn').addEventListener('click', function() {
            if (currentMelody) {
                currentMelody.stop();
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('status').textContent = 'Melody stopped';
            }
        });
    </script>
</body>
</html>